---
description: 
globs: 
alwaysApply: true
---
We are bulilding a two pass assembler in C language, according to the instructions in the file assembler-turorial.pdf.
Act as a senior software engineer, with 15 years of experience in C language and assembler building. Write a documented code, avoid using "continue" and "break", and write the code according to C90. Do not do something that is not defined in 
assembler-turorial.pdf.
For the assembler first pass, here is the skeleton algorithm:
First Pass Skeleton Algorithm

1. Initialize counters:

    Set IC (Instruction Counter) to 100
    Set DC (Data Counter) to 0


2. Read the next line from the input file:

    If end of file is reached, go to step 17
    Increment line counter


3. Check if the first field is a symbol (label):

    If yes, set a flag indicating a symbol definition was found


4. Check the next field (or first field if no symbol):

    If the line is empty or a comment, go back to step 2


5. Check if line contains a data storage directive (.data or .string):

    If yes, go to step 6
    If no, go to step 8


6. If symbol definition found, add symbol to the symbol table:

    Set the symbol value to current DC
    Set symbol type as DATA
    Check for duplicate symbol definitions


7. Encode the data values in memory, update DC:

    For .data: encode each number in the data image
    For .string: encode each character plus null terminator
    Increment DC accordingly
    Go back to step 2


8. Check if line contains .extern or .entry directive:

    If yes, go to step 9
    If no, go to step 11


9.If directive is .entry, skip it (will be handled in second pass)
10. If directive is .extern, add symbol to symbol table:

    Set symbol value to 0
    Set symbol type as EXTERNAL
    Go back to step 2


11. If symbol definition found, add to symbol table:

    Set symbol value to current IC
    Set symbol type as CODE
    Check for duplicate symbol definitions


12. Find the instruction's opcode in the opcode table:

    If not found, report error


13. Analyze the operands of the instruction:

    Determine addressing modes
    Calculate the total word count (L) for this instruction


14. Build the binary code for the first word of the instruction:

    Encode opcode, addressing modes, etc.
    For operands that don't depend on external symbols, encode them too


15. Save current IC and L values along with the machine code generated

16. Update IC = IC + L, and go to step 2

17. End of first pass, save final values of IC and DC as ICF and DCF

18. Update data symbols in symbol table by adding ICF to their values

    This ensures data addresses follow the code segment in memory


Begin second pass